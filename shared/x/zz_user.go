package x

// GENERATED BY XO. DO NOT EDIT.
import (
	"errors"
	"strings"
	//"time"
	"strconv"

	"github.com/jmoiron/sqlx"
)

// (shortname .TableNameGo "err" "res" "sqlstr" "db" "XOLog") -}}//(schema .Schema .Table.TableName) -}}// .TableNameGo}}// User represents a row from 'sun.user'.

// Manualy copy this to project
type User__ struct {
	UserId             int    `json:"UserId"`             // UserId -
	UserName           string `json:"UserName"`           // UserName -
	UserNameLower      string `json:"UserNameLower"`      // UserNameLower -
	FirstName          string `json:"FirstName"`          // FirstName -
	LastName           string `json:"LastName"`           // LastName -
	IsVerified         int    `json:"IsVerified"`         // IsVerified -
	AvatarId           int    `json:"AvatarId"`           // AvatarId -
	ProfilePrivacy     int    `json:"ProfilePrivacy"`     // ProfilePrivacy -
	OnlinePrivacy      int    `json:"OnlinePrivacy"`      // OnlinePrivacy -
	CallPrivacy        int    `json:"CallPrivacy"`        // CallPrivacy -
	AddToGroupPrivacy  int    `json:"AddToGroupPrivacy"`  // AddToGroupPrivacy -
	SeenMessagePrivacy int    `json:"SeenMessagePrivacy"` // SeenMessagePrivacy -
	Phone              int    `json:"Phone"`              // Phone -
	Email              string `json:"Email"`              // Email -
	About              string `json:"About"`              // About -
	PasswordHash       string `json:"PasswordHash"`       // PasswordHash -
	PasswordSalt       string `json:"PasswordSalt"`       // PasswordSalt -
	PostSeq            int    `json:"PostSeq"`            // PostSeq -
	FollowersCount     int    `json:"FollowersCount"`     // FollowersCount -
	FollowingCount     int    `json:"FollowingCount"`     // FollowingCount -
	PostsCount         int    `json:"PostsCount"`         // PostsCount -
	MediaCount         int    `json:"MediaCount"`         // MediaCount -
	PhotoCount         int    `json:"PhotoCount"`         // PhotoCount -
	VideoCount         int    `json:"VideoCount"`         // VideoCount -
	GifCount           int    `json:"GifCount"`           // GifCount -
	AudioCount         int    `json:"AudioCount"`         // AudioCount -
	VoiceCount         int    `json:"VoiceCount"`         // VoiceCount -
	FileCount          int    `json:"FileCount"`          // FileCount -
	LinkCount          int    `json:"LinkCount"`          // LinkCount -
	BoardCount         int    `json:"BoardCount"`         // BoardCount -
	PinedCount         int    `json:"PinedCount"`         // PinedCount -
	LikesCount         int    `json:"LikesCount"`         // LikesCount -
	ResharedCount      int    `json:"ResharedCount"`      // ResharedCount -
	LastPostTime       int    `json:"LastPostTime"`       // LastPostTime -
	CreatedTime        int    `json:"CreatedTime"`        // CreatedTime -
	VersionTime        int    `json:"VersionTime"`        // VersionTime -
	IsDeleted          int    `json:"IsDeleted"`          // IsDeleted -
	IsBanned           int    `json:"IsBanned"`           // IsBanned -
	// xo fields
	_exists, _deleted bool
}

// Exists determines if the User exists in the database.
func (u *User) Exists() bool {
	return u._exists
}

// Deleted provides information if the User has been deleted from the database.
func (u *User) Deleted() bool {
	return u._deleted
}

// Insert inserts the User to the database.
func (u *User) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if u._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO sun.user (` +
		`UserName, UserNameLower, FirstName, LastName, IsVerified, AvatarId, ProfilePrivacy, OnlinePrivacy, CallPrivacy, AddToGroupPrivacy, SeenMessagePrivacy, Phone, Email, About, PasswordHash, PasswordSalt, PostSeq, FollowersCount, FollowingCount, PostsCount, MediaCount, PhotoCount, VideoCount, GifCount, AudioCount, VoiceCount, FileCount, LinkCount, BoardCount, PinedCount, LikesCount, ResharedCount, LastPostTime, CreatedTime, VersionTime, IsDeleted, IsBanned` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	if LogTableSqlReq.User {
		XOLog(sqlstr, u.UserName, u.UserNameLower, u.FirstName, u.LastName, u.IsVerified, u.AvatarId, u.ProfilePrivacy, u.OnlinePrivacy, u.CallPrivacy, u.AddToGroupPrivacy, u.SeenMessagePrivacy, u.Phone, u.Email, u.About, u.PasswordHash, u.PasswordSalt, u.PostSeq, u.FollowersCount, u.FollowingCount, u.PostsCount, u.MediaCount, u.PhotoCount, u.VideoCount, u.GifCount, u.AudioCount, u.VoiceCount, u.FileCount, u.LinkCount, u.BoardCount, u.PinedCount, u.LikesCount, u.ResharedCount, u.LastPostTime, u.CreatedTime, u.VersionTime, u.IsDeleted, u.IsBanned)
	}
	res, err := db.Exec(sqlstr, u.UserName, u.UserNameLower, u.FirstName, u.LastName, u.IsVerified, u.AvatarId, u.ProfilePrivacy, u.OnlinePrivacy, u.CallPrivacy, u.AddToGroupPrivacy, u.SeenMessagePrivacy, u.Phone, u.Email, u.About, u.PasswordHash, u.PasswordSalt, u.PostSeq, u.FollowersCount, u.FollowingCount, u.PostsCount, u.MediaCount, u.PhotoCount, u.VideoCount, u.GifCount, u.AudioCount, u.VoiceCount, u.FileCount, u.LinkCount, u.BoardCount, u.PinedCount, u.LikesCount, u.ResharedCount, u.LastPostTime, u.CreatedTime, u.VersionTime, u.IsDeleted, u.IsBanned)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return err
	}

	// set primary key and existence
	u.UserId = int(id)
	u._exists = true

	OnUser_AfterInsert(u)

	return nil
}

// Insert inserts the User to the database.
func (u *User) Replace(db XODB) error {
	var err error

	// sql query

	const sqlstr = `REPLACE INTO sun.user (` +
		`UserName, UserNameLower, FirstName, LastName, IsVerified, AvatarId, ProfilePrivacy, OnlinePrivacy, CallPrivacy, AddToGroupPrivacy, SeenMessagePrivacy, Phone, Email, About, PasswordHash, PasswordSalt, PostSeq, FollowersCount, FollowingCount, PostsCount, MediaCount, PhotoCount, VideoCount, GifCount, AudioCount, VoiceCount, FileCount, LinkCount, BoardCount, PinedCount, LikesCount, ResharedCount, LastPostTime, CreatedTime, VersionTime, IsDeleted, IsBanned` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	if LogTableSqlReq.User {
		XOLog(sqlstr, u.UserName, u.UserNameLower, u.FirstName, u.LastName, u.IsVerified, u.AvatarId, u.ProfilePrivacy, u.OnlinePrivacy, u.CallPrivacy, u.AddToGroupPrivacy, u.SeenMessagePrivacy, u.Phone, u.Email, u.About, u.PasswordHash, u.PasswordSalt, u.PostSeq, u.FollowersCount, u.FollowingCount, u.PostsCount, u.MediaCount, u.PhotoCount, u.VideoCount, u.GifCount, u.AudioCount, u.VoiceCount, u.FileCount, u.LinkCount, u.BoardCount, u.PinedCount, u.LikesCount, u.ResharedCount, u.LastPostTime, u.CreatedTime, u.VersionTime, u.IsDeleted, u.IsBanned)
	}
	res, err := db.Exec(sqlstr, u.UserName, u.UserNameLower, u.FirstName, u.LastName, u.IsVerified, u.AvatarId, u.ProfilePrivacy, u.OnlinePrivacy, u.CallPrivacy, u.AddToGroupPrivacy, u.SeenMessagePrivacy, u.Phone, u.Email, u.About, u.PasswordHash, u.PasswordSalt, u.PostSeq, u.FollowersCount, u.FollowingCount, u.PostsCount, u.MediaCount, u.PhotoCount, u.VideoCount, u.GifCount, u.AudioCount, u.VoiceCount, u.FileCount, u.LinkCount, u.BoardCount, u.PinedCount, u.LikesCount, u.ResharedCount, u.LastPostTime, u.CreatedTime, u.VersionTime, u.IsDeleted, u.IsBanned)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return err
	}

	// set primary key and existence
	u.UserId = int(id)
	u._exists = true

	OnUser_AfterInsert(u)

	return nil
}

// Update updates the User in the database.
func (u *User) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !u._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if u._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE sun.user SET ` +
		`UserName = ?, UserNameLower = ?, FirstName = ?, LastName = ?, IsVerified = ?, AvatarId = ?, ProfilePrivacy = ?, OnlinePrivacy = ?, CallPrivacy = ?, AddToGroupPrivacy = ?, SeenMessagePrivacy = ?, Phone = ?, Email = ?, About = ?, PasswordHash = ?, PasswordSalt = ?, PostSeq = ?, FollowersCount = ?, FollowingCount = ?, PostsCount = ?, MediaCount = ?, PhotoCount = ?, VideoCount = ?, GifCount = ?, AudioCount = ?, VoiceCount = ?, FileCount = ?, LinkCount = ?, BoardCount = ?, PinedCount = ?, LikesCount = ?, ResharedCount = ?, LastPostTime = ?, CreatedTime = ?, VersionTime = ?, IsDeleted = ?, IsBanned = ?` +
		` WHERE UserId = ?`

	// run query
	if LogTableSqlReq.User {
		XOLog(sqlstr, u.UserName, u.UserNameLower, u.FirstName, u.LastName, u.IsVerified, u.AvatarId, u.ProfilePrivacy, u.OnlinePrivacy, u.CallPrivacy, u.AddToGroupPrivacy, u.SeenMessagePrivacy, u.Phone, u.Email, u.About, u.PasswordHash, u.PasswordSalt, u.PostSeq, u.FollowersCount, u.FollowingCount, u.PostsCount, u.MediaCount, u.PhotoCount, u.VideoCount, u.GifCount, u.AudioCount, u.VoiceCount, u.FileCount, u.LinkCount, u.BoardCount, u.PinedCount, u.LikesCount, u.ResharedCount, u.LastPostTime, u.CreatedTime, u.VersionTime, u.IsDeleted, u.IsBanned, u.UserId)
	}
	_, err = db.Exec(sqlstr, u.UserName, u.UserNameLower, u.FirstName, u.LastName, u.IsVerified, u.AvatarId, u.ProfilePrivacy, u.OnlinePrivacy, u.CallPrivacy, u.AddToGroupPrivacy, u.SeenMessagePrivacy, u.Phone, u.Email, u.About, u.PasswordHash, u.PasswordSalt, u.PostSeq, u.FollowersCount, u.FollowingCount, u.PostsCount, u.MediaCount, u.PhotoCount, u.VideoCount, u.GifCount, u.AudioCount, u.VoiceCount, u.FileCount, u.LinkCount, u.BoardCount, u.PinedCount, u.LikesCount, u.ResharedCount, u.LastPostTime, u.CreatedTime, u.VersionTime, u.IsDeleted, u.IsBanned, u.UserId)

	if LogTableSqlReq.User {
		XOLogErr(err)
	}
	OnUser_AfterUpdate(u)

	return err
}

// Save saves the User to the database.
func (u *User) Save(db XODB) error {
	if u.Exists() {
		return u.Update(db)
	}

	return u.Replace(db)
}

// Delete deletes the User from the database.
func (u *User) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !u._exists {
		return nil
	}

	// if deleted, bail
	if u._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM sun.user WHERE UserId = ?`

	// run query
	if LogTableSqlReq.User {
		XOLog(sqlstr, u.UserId)
	}
	_, err = db.Exec(sqlstr, u.UserId)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return err
	}

	// set deleted
	u._deleted = true

	OnUser_AfterDelete(u)

	return nil
}

////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Querify gen - ME /////////////////////////////////////////
//.TableNameGo= table name
// _Deleter, _Updater

// orma types
type __User_Deleter struct {
	wheres      []whereClause
	whereSep    string
	dollarIndex int
	isMysql     bool
}

type __User_Updater struct {
	wheres []whereClause
	// updates   map[string]interface{}
	updates     []updateCol
	whereSep    string
	dollarIndex int
	isMysql     bool
}

type __User_Selector struct {
	wheres      []whereClause
	selectCol   string
	whereSep    string
	orderBy     string //" order by id desc //for ints
	limit       int
	offset      int
	dollarIndex int
	isMysql     bool
}

func NewUser_Deleter() *__User_Deleter {
	d := __User_Deleter{whereSep: " AND "}
	return &d
}

func NewUser_Updater() *__User_Updater {
	u := __User_Updater{whereSep: " AND "}
	//u.updates =  make(map[string]interface{},10)
	return &u
}

func NewUser_Selector() *__User_Selector {
	u := __User_Selector{whereSep: " AND ", selectCol: "*"}
	return &u
}

/*/// mysql or cockroach ? or $1 handlers
func (m *__User_Selector)nextDollars(size int) string  {
    r := DollarsForSqlIn(size,m.dollarIndex,m.isMysql)
    m.dollarIndex += size
    return r
}

func (m *__User_Selector)nextDollar() string  {
    r := DollarsForSqlIn(1,m.dollarIndex,m.isMysql)
    m.dollarIndex += 1
    return r
}

*/
/////////////////////////////// Where for all /////////////////////////////
//// for ints all selector updater, deleter

/// mysql or cockroach ? or $1 handlers
func (m *__User_Deleter) nextDollars(size int) string {
	r := DollarsForSqlIn(size, m.dollarIndex, m.isMysql)
	m.dollarIndex += size
	return r
}

func (m *__User_Deleter) nextDollar() string {
	r := DollarsForSqlIn(1, m.dollarIndex, m.isMysql)
	m.dollarIndex += 1
	return r
}

////////ints
func (u *__User_Deleter) Or() *__User_Deleter {
	u.whereSep = " OR "
	return u
}

func (u *__User_Deleter) UserId_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) UserId_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) UserId_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) UserId_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) UserId_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) UserId_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) UserId_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) UserId_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) UserId_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) IsVerified_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) IsVerified_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) IsVerified_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) IsVerified_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsVerified_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsVerified_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsVerified_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsVerified_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsVerified_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) AvatarId_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) AvatarId_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) AvatarId_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) AvatarId_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AvatarId_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AvatarId_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AvatarId_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AvatarId_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AvatarId_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) ProfilePrivacy_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) ProfilePrivacy_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) ProfilePrivacy_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) ProfilePrivacy_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ProfilePrivacy_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ProfilePrivacy_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ProfilePrivacy_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ProfilePrivacy_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ProfilePrivacy_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) OnlinePrivacy_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) OnlinePrivacy_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) OnlinePrivacy_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) OnlinePrivacy_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) OnlinePrivacy_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) OnlinePrivacy_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) OnlinePrivacy_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) OnlinePrivacy_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) OnlinePrivacy_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) CallPrivacy_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) CallPrivacy_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) CallPrivacy_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) CallPrivacy_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CallPrivacy_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CallPrivacy_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CallPrivacy_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CallPrivacy_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CallPrivacy_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) AddToGroupPrivacy_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) AddToGroupPrivacy_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) AddToGroupPrivacy_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) AddToGroupPrivacy_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AddToGroupPrivacy_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AddToGroupPrivacy_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AddToGroupPrivacy_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AddToGroupPrivacy_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AddToGroupPrivacy_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) SeenMessagePrivacy_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) SeenMessagePrivacy_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) SeenMessagePrivacy_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) SeenMessagePrivacy_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) SeenMessagePrivacy_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) SeenMessagePrivacy_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) SeenMessagePrivacy_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) SeenMessagePrivacy_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) SeenMessagePrivacy_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) Phone_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) Phone_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) Phone_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) Phone_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) Phone_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) Phone_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) Phone_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) Phone_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) Phone_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) PostSeq_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PostSeq_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PostSeq_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) PostSeq_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostSeq_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostSeq_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostSeq_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostSeq_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostSeq_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) FollowersCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) FollowersCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) FollowersCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) FollowersCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowersCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowersCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowersCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowersCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowersCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) FollowingCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) FollowingCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) FollowingCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) FollowingCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowingCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowingCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowingCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowingCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FollowingCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) PostsCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PostsCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PostsCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) PostsCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostsCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostsCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostsCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostsCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PostsCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) MediaCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) MediaCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) MediaCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) MediaCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) MediaCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) MediaCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) MediaCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) MediaCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) MediaCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) PhotoCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PhotoCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PhotoCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) PhotoCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PhotoCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PhotoCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PhotoCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PhotoCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PhotoCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) VideoCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) VideoCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) VideoCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) VideoCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VideoCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VideoCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VideoCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VideoCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VideoCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) GifCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) GifCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) GifCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) GifCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) GifCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) GifCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) GifCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) GifCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) GifCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) AudioCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) AudioCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) AudioCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) AudioCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AudioCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AudioCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AudioCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AudioCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) AudioCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) VoiceCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) VoiceCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) VoiceCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) VoiceCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VoiceCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VoiceCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VoiceCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VoiceCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VoiceCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) FileCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) FileCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) FileCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) FileCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FileCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FileCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FileCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FileCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FileCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) LinkCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) LinkCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) LinkCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) LinkCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LinkCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LinkCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LinkCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LinkCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LinkCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) BoardCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) BoardCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) BoardCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) BoardCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) BoardCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) BoardCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) BoardCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) BoardCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) BoardCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) PinedCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PinedCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PinedCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) PinedCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PinedCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PinedCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PinedCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PinedCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PinedCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) LikesCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) LikesCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) LikesCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) LikesCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LikesCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LikesCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LikesCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LikesCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LikesCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) ResharedCount_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) ResharedCount_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) ResharedCount_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) ResharedCount_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ResharedCount_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ResharedCount_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ResharedCount_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ResharedCount_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) ResharedCount_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) LastPostTime_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) LastPostTime_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) LastPostTime_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) LastPostTime_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LastPostTime_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LastPostTime_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LastPostTime_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LastPostTime_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LastPostTime_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) CreatedTime_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) CreatedTime_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) CreatedTime_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) CreatedTime_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CreatedTime_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CreatedTime_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CreatedTime_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CreatedTime_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) CreatedTime_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) VersionTime_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) VersionTime_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) VersionTime_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) VersionTime_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VersionTime_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VersionTime_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VersionTime_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VersionTime_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) VersionTime_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) IsDeleted_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) IsDeleted_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) IsDeleted_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) IsDeleted_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsDeleted_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsDeleted_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsDeleted_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsDeleted_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsDeleted_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) IsBanned_In(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) IsBanned_Ins(ins ...int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) IsBanned_NotIn(ins []int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) IsBanned_Eq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsBanned_NotEq(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsBanned_LT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsBanned_LE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsBanned_GT(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) IsBanned_GE(val int) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

/// mysql or cockroach ? or $1 handlers
func (m *__User_Updater) nextDollars(size int) string {
	r := DollarsForSqlIn(size, m.dollarIndex, m.isMysql)
	m.dollarIndex += size
	return r
}

func (m *__User_Updater) nextDollar() string {
	r := DollarsForSqlIn(1, m.dollarIndex, m.isMysql)
	m.dollarIndex += 1
	return r
}

////////ints
func (u *__User_Updater) Or() *__User_Updater {
	u.whereSep = " OR "
	return u
}

func (u *__User_Updater) UserId_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) UserId_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) UserId_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) UserId_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) UserId_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) UserId_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) UserId_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) UserId_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) UserId_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) IsVerified_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) IsVerified_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) IsVerified_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) IsVerified_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsVerified_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsVerified_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsVerified_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsVerified_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsVerified_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) AvatarId_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) AvatarId_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) AvatarId_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) AvatarId_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AvatarId_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AvatarId_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AvatarId_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AvatarId_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AvatarId_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) ProfilePrivacy_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) ProfilePrivacy_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) ProfilePrivacy_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) ProfilePrivacy_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ProfilePrivacy_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ProfilePrivacy_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ProfilePrivacy_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ProfilePrivacy_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ProfilePrivacy_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) OnlinePrivacy_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) OnlinePrivacy_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) OnlinePrivacy_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) OnlinePrivacy_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) OnlinePrivacy_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) OnlinePrivacy_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) OnlinePrivacy_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) OnlinePrivacy_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) OnlinePrivacy_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) CallPrivacy_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) CallPrivacy_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) CallPrivacy_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) CallPrivacy_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CallPrivacy_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CallPrivacy_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CallPrivacy_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CallPrivacy_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CallPrivacy_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) AddToGroupPrivacy_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) AddToGroupPrivacy_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) AddToGroupPrivacy_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) AddToGroupPrivacy_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AddToGroupPrivacy_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AddToGroupPrivacy_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AddToGroupPrivacy_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AddToGroupPrivacy_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AddToGroupPrivacy_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) SeenMessagePrivacy_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) SeenMessagePrivacy_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) SeenMessagePrivacy_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) SeenMessagePrivacy_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) SeenMessagePrivacy_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) SeenMessagePrivacy_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) SeenMessagePrivacy_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) SeenMessagePrivacy_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) SeenMessagePrivacy_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) Phone_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) Phone_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) Phone_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) Phone_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) Phone_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) Phone_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) Phone_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) Phone_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) Phone_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) PostSeq_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PostSeq_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PostSeq_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) PostSeq_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostSeq_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostSeq_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostSeq_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostSeq_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostSeq_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) FollowersCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) FollowersCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) FollowersCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) FollowersCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowersCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowersCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowersCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowersCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowersCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) FollowingCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) FollowingCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) FollowingCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) FollowingCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowingCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowingCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowingCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowingCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FollowingCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) PostsCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PostsCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PostsCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) PostsCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostsCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostsCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostsCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostsCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PostsCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) MediaCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) MediaCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) MediaCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) MediaCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) MediaCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) MediaCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) MediaCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) MediaCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) MediaCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) PhotoCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PhotoCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PhotoCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) PhotoCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PhotoCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PhotoCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PhotoCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PhotoCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PhotoCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) VideoCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) VideoCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) VideoCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) VideoCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VideoCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VideoCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VideoCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VideoCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VideoCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) GifCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) GifCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) GifCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) GifCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) GifCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) GifCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) GifCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) GifCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) GifCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) AudioCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) AudioCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) AudioCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) AudioCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AudioCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AudioCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AudioCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AudioCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) AudioCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) VoiceCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) VoiceCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) VoiceCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) VoiceCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VoiceCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VoiceCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VoiceCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VoiceCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VoiceCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) FileCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) FileCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) FileCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) FileCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FileCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FileCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FileCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FileCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FileCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) LinkCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) LinkCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) LinkCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) LinkCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LinkCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LinkCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LinkCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LinkCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LinkCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) BoardCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) BoardCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) BoardCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) BoardCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) BoardCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) BoardCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) BoardCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) BoardCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) BoardCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) PinedCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PinedCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PinedCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) PinedCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PinedCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PinedCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PinedCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PinedCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PinedCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) LikesCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) LikesCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) LikesCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) LikesCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LikesCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LikesCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LikesCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LikesCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LikesCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) ResharedCount_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) ResharedCount_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) ResharedCount_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) ResharedCount_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ResharedCount_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ResharedCount_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ResharedCount_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ResharedCount_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) ResharedCount_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) LastPostTime_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) LastPostTime_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) LastPostTime_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) LastPostTime_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LastPostTime_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LastPostTime_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LastPostTime_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LastPostTime_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LastPostTime_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) CreatedTime_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) CreatedTime_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) CreatedTime_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) CreatedTime_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CreatedTime_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CreatedTime_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CreatedTime_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CreatedTime_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) CreatedTime_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) VersionTime_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) VersionTime_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) VersionTime_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) VersionTime_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VersionTime_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VersionTime_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VersionTime_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VersionTime_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) VersionTime_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) IsDeleted_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) IsDeleted_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) IsDeleted_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) IsDeleted_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsDeleted_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsDeleted_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsDeleted_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsDeleted_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsDeleted_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) IsBanned_In(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) IsBanned_Ins(ins ...int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) IsBanned_NotIn(ins []int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) IsBanned_Eq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsBanned_NotEq(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsBanned_LT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsBanned_LE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsBanned_GT(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) IsBanned_GE(val int) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

/// mysql or cockroach ? or $1 handlers
func (m *__User_Selector) nextDollars(size int) string {
	r := DollarsForSqlIn(size, m.dollarIndex, m.isMysql)
	m.dollarIndex += size
	return r
}

func (m *__User_Selector) nextDollar() string {
	r := DollarsForSqlIn(1, m.dollarIndex, m.isMysql)
	m.dollarIndex += 1
	return r
}

////////ints
func (u *__User_Selector) Or() *__User_Selector {
	u.whereSep = " OR "
	return u
}

func (u *__User_Selector) UserId_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) UserId_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) UserId_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserId NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) UserId_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) UserId_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) UserId_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) UserId_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) UserId_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) UserId_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserId >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) IsVerified_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) IsVerified_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) IsVerified_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsVerified NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) IsVerified_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsVerified_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsVerified_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsVerified_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsVerified_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsVerified_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsVerified >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) AvatarId_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) AvatarId_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) AvatarId_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AvatarId NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) AvatarId_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AvatarId_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AvatarId_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AvatarId_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AvatarId_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AvatarId_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AvatarId >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) ProfilePrivacy_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) ProfilePrivacy_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) ProfilePrivacy_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ProfilePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) ProfilePrivacy_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ProfilePrivacy_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ProfilePrivacy_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ProfilePrivacy_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ProfilePrivacy_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ProfilePrivacy_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ProfilePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) OnlinePrivacy_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) OnlinePrivacy_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) OnlinePrivacy_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " OnlinePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) OnlinePrivacy_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) OnlinePrivacy_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) OnlinePrivacy_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) OnlinePrivacy_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) OnlinePrivacy_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) OnlinePrivacy_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " OnlinePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) CallPrivacy_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) CallPrivacy_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) CallPrivacy_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CallPrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) CallPrivacy_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CallPrivacy_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CallPrivacy_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CallPrivacy_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CallPrivacy_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CallPrivacy_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CallPrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) AddToGroupPrivacy_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) AddToGroupPrivacy_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) AddToGroupPrivacy_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AddToGroupPrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) AddToGroupPrivacy_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AddToGroupPrivacy_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AddToGroupPrivacy_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AddToGroupPrivacy_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AddToGroupPrivacy_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AddToGroupPrivacy_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AddToGroupPrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) SeenMessagePrivacy_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) SeenMessagePrivacy_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) SeenMessagePrivacy_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " SeenMessagePrivacy NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) SeenMessagePrivacy_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) SeenMessagePrivacy_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) SeenMessagePrivacy_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) SeenMessagePrivacy_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) SeenMessagePrivacy_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) SeenMessagePrivacy_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " SeenMessagePrivacy >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) Phone_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) Phone_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) Phone_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Phone NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) Phone_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) Phone_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) Phone_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) Phone_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) Phone_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) Phone_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Phone >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) PostSeq_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PostSeq_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PostSeq_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostSeq NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) PostSeq_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostSeq_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostSeq_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostSeq_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostSeq_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostSeq_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostSeq >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) FollowersCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) FollowersCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) FollowersCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowersCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) FollowersCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowersCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowersCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowersCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowersCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowersCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowersCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) FollowingCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) FollowingCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) FollowingCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FollowingCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) FollowingCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowingCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowingCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowingCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowingCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FollowingCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FollowingCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) PostsCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PostsCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PostsCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PostsCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) PostsCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostsCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostsCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostsCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostsCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PostsCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PostsCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) MediaCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) MediaCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) MediaCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " MediaCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) MediaCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) MediaCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) MediaCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) MediaCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) MediaCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) MediaCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " MediaCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) PhotoCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PhotoCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PhotoCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PhotoCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) PhotoCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PhotoCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PhotoCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PhotoCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PhotoCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PhotoCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PhotoCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) VideoCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) VideoCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) VideoCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VideoCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) VideoCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VideoCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VideoCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VideoCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VideoCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VideoCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VideoCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) GifCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) GifCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) GifCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " GifCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) GifCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) GifCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) GifCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) GifCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) GifCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) GifCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " GifCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) AudioCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) AudioCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) AudioCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " AudioCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) AudioCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AudioCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AudioCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AudioCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AudioCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) AudioCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " AudioCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) VoiceCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) VoiceCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) VoiceCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VoiceCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) VoiceCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VoiceCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VoiceCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VoiceCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VoiceCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VoiceCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VoiceCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) FileCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) FileCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) FileCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FileCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) FileCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FileCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FileCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FileCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FileCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FileCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FileCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) LinkCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) LinkCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) LinkCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LinkCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) LinkCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LinkCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LinkCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LinkCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LinkCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LinkCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LinkCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) BoardCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) BoardCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) BoardCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " BoardCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) BoardCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) BoardCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) BoardCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) BoardCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) BoardCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) BoardCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " BoardCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) PinedCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PinedCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PinedCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PinedCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) PinedCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PinedCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PinedCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PinedCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PinedCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PinedCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PinedCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) LikesCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) LikesCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) LikesCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LikesCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) LikesCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LikesCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LikesCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LikesCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LikesCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LikesCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LikesCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) ResharedCount_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) ResharedCount_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) ResharedCount_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " ResharedCount NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) ResharedCount_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ResharedCount_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ResharedCount_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ResharedCount_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ResharedCount_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) ResharedCount_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " ResharedCount >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) LastPostTime_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) LastPostTime_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) LastPostTime_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastPostTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) LastPostTime_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LastPostTime_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LastPostTime_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LastPostTime_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LastPostTime_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LastPostTime_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastPostTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) CreatedTime_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) CreatedTime_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) CreatedTime_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " CreatedTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) CreatedTime_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CreatedTime_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CreatedTime_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CreatedTime_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CreatedTime_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) CreatedTime_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " CreatedTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) VersionTime_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) VersionTime_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) VersionTime_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " VersionTime NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) VersionTime_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VersionTime_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VersionTime_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VersionTime_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VersionTime_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) VersionTime_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " VersionTime >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) IsDeleted_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) IsDeleted_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) IsDeleted_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsDeleted NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) IsDeleted_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsDeleted_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsDeleted_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsDeleted_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsDeleted_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsDeleted_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsDeleted >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) IsBanned_In(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) IsBanned_Ins(ins ...int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) IsBanned_NotIn(ins []int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " IsBanned NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) IsBanned_Eq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsBanned_NotEq(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsBanned_LT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned < " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsBanned_LE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned <= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsBanned_GT(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned > " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) IsBanned_GE(val int) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " IsBanned >= " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

///// for strings //copy of above with type int -> string + rm if eq + $ms_str_cond

////////ints

func (u *__User_Deleter) UserName_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) UserName_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) UserName_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) UserName_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) UserName_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) UserNameLower_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserNameLower IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) UserNameLower_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserNameLower NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) UserNameLower_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) UserNameLower_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) UserNameLower_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) FirstName_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FirstName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) FirstName_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FirstName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) FirstName_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) FirstName_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) FirstName_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) LastName_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) LastName_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) LastName_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) LastName_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) LastName_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) Email_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Email IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) Email_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Email NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) Email_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) Email_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) Email_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) About_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " About IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) About_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " About NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) About_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) About_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) About_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) PasswordHash_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordHash IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PasswordHash_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordHash NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) PasswordHash_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) PasswordHash_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PasswordHash_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Deleter) PasswordSalt_In(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordSalt IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Deleter) PasswordSalt_NotIn(ins []string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordSalt NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Deleter) PasswordSalt_Like(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Deleter) PasswordSalt_Eq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Deleter) PasswordSalt_NotEq(val string) *__User_Deleter {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

////////ints

func (u *__User_Updater) UserName_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) UserName_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) UserName_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) UserName_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) UserName_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) UserNameLower_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserNameLower IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) UserNameLower_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserNameLower NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) UserNameLower_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) UserNameLower_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) UserNameLower_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) FirstName_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FirstName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) FirstName_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FirstName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) FirstName_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) FirstName_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) FirstName_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) LastName_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) LastName_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) LastName_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) LastName_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) LastName_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) Email_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Email IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) Email_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Email NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) Email_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) Email_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) Email_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) About_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " About IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) About_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " About NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) About_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) About_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) About_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) PasswordHash_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordHash IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PasswordHash_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordHash NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) PasswordHash_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) PasswordHash_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PasswordHash_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Updater) PasswordSalt_In(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordSalt IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Updater) PasswordSalt_NotIn(ins []string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordSalt NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Updater) PasswordSalt_Like(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Updater) PasswordSalt_Eq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Updater) PasswordSalt_NotEq(val string) *__User_Updater {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

////////ints

func (u *__User_Selector) UserName_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) UserName_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) UserName_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) UserName_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) UserName_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) UserNameLower_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserNameLower IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) UserNameLower_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " UserNameLower NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) UserNameLower_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) UserNameLower_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) UserNameLower_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " UserNameLower != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) FirstName_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FirstName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) FirstName_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " FirstName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) FirstName_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) FirstName_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) FirstName_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " FirstName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) LastName_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastName IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) LastName_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " LastName NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) LastName_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) LastName_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) LastName_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " LastName != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) Email_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Email IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) Email_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " Email NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) Email_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) Email_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) Email_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " Email != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) About_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " About IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) About_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " About NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) About_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) About_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) About_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " About != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) PasswordHash_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordHash IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PasswordHash_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordHash NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) PasswordHash_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) PasswordHash_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PasswordHash_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordHash != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (u *__User_Selector) PasswordSalt_In(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordSalt IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

func (u *__User_Selector) PasswordSalt_NotIn(ins []string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	for _, i := range ins {
		insWhere = append(insWhere, i)
	}
	w.args = insWhere
	w.condition = " PasswordSalt NOT IN(" + u.nextDollars(len(ins)) + ") "
	u.wheres = append(u.wheres, w)

	return u
}

//must be used like: UserName_like("hamid%")
func (u *__User_Selector) PasswordSalt_Like(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt LIKE " + u.nextDollar()
	u.wheres = append(u.wheres, w)

	return u
}

func (d *__User_Selector) PasswordSalt_Eq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt = " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

func (d *__User_Selector) PasswordSalt_NotEq(val string) *__User_Selector {
	w := whereClause{}
	var insWhere []interface{}
	insWhere = append(insWhere, val)
	w.args = insWhere
	w.condition = " PasswordSalt != " + d.nextDollar()
	d.wheres = append(d.wheres, w)

	return d
}

/// End of wheres for selectors , updators, deletor

/////////////////////////////// Updater /////////////////////////////

//ints

func (u *__User_Updater) UserId(newVal int) *__User_Updater {
	up := updateCol{" UserId = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" UserId = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) UserId_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" UserId = UserId+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" UserId = UserId+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" UserId = UserId- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" UserId = UserId- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

//string
func (u *__User_Updater) UserName(newVal string) *__User_Updater {
	up := updateCol{"UserName = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" UserName = "+ u.nextDollar()] = newVal
	return u
}

//ints

//string
func (u *__User_Updater) UserNameLower(newVal string) *__User_Updater {
	up := updateCol{"UserNameLower = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" UserNameLower = "+ u.nextDollar()] = newVal
	return u
}

//ints

//string
func (u *__User_Updater) FirstName(newVal string) *__User_Updater {
	up := updateCol{"FirstName = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" FirstName = "+ u.nextDollar()] = newVal
	return u
}

//ints

//string
func (u *__User_Updater) LastName(newVal string) *__User_Updater {
	up := updateCol{"LastName = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" LastName = "+ u.nextDollar()] = newVal
	return u
}

//ints

func (u *__User_Updater) IsVerified(newVal int) *__User_Updater {
	up := updateCol{" IsVerified = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" IsVerified = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) IsVerified_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" IsVerified = IsVerified+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" IsVerified = IsVerified+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" IsVerified = IsVerified- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" IsVerified = IsVerified- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) AvatarId(newVal int) *__User_Updater {
	up := updateCol{" AvatarId = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" AvatarId = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) AvatarId_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" AvatarId = AvatarId+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" AvatarId = AvatarId+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" AvatarId = AvatarId- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" AvatarId = AvatarId- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) ProfilePrivacy(newVal int) *__User_Updater {
	up := updateCol{" ProfilePrivacy = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" ProfilePrivacy = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) ProfilePrivacy_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" ProfilePrivacy = ProfilePrivacy+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" ProfilePrivacy = ProfilePrivacy+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" ProfilePrivacy = ProfilePrivacy- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" ProfilePrivacy = ProfilePrivacy- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) OnlinePrivacy(newVal int) *__User_Updater {
	up := updateCol{" OnlinePrivacy = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" OnlinePrivacy = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) OnlinePrivacy_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" OnlinePrivacy = OnlinePrivacy+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" OnlinePrivacy = OnlinePrivacy+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" OnlinePrivacy = OnlinePrivacy- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" OnlinePrivacy = OnlinePrivacy- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) CallPrivacy(newVal int) *__User_Updater {
	up := updateCol{" CallPrivacy = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" CallPrivacy = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) CallPrivacy_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" CallPrivacy = CallPrivacy+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" CallPrivacy = CallPrivacy+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" CallPrivacy = CallPrivacy- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" CallPrivacy = CallPrivacy- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) AddToGroupPrivacy(newVal int) *__User_Updater {
	up := updateCol{" AddToGroupPrivacy = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" AddToGroupPrivacy = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) AddToGroupPrivacy_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" AddToGroupPrivacy = AddToGroupPrivacy+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" AddToGroupPrivacy = AddToGroupPrivacy+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" AddToGroupPrivacy = AddToGroupPrivacy- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" AddToGroupPrivacy = AddToGroupPrivacy- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) SeenMessagePrivacy(newVal int) *__User_Updater {
	up := updateCol{" SeenMessagePrivacy = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" SeenMessagePrivacy = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) SeenMessagePrivacy_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" SeenMessagePrivacy = SeenMessagePrivacy+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" SeenMessagePrivacy = SeenMessagePrivacy+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" SeenMessagePrivacy = SeenMessagePrivacy- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" SeenMessagePrivacy = SeenMessagePrivacy- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) Phone(newVal int) *__User_Updater {
	up := updateCol{" Phone = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" Phone = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) Phone_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" Phone = Phone+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" Phone = Phone+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" Phone = Phone- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" Phone = Phone- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

//string
func (u *__User_Updater) Email(newVal string) *__User_Updater {
	up := updateCol{"Email = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" Email = "+ u.nextDollar()] = newVal
	return u
}

//ints

//string
func (u *__User_Updater) About(newVal string) *__User_Updater {
	up := updateCol{"About = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" About = "+ u.nextDollar()] = newVal
	return u
}

//ints

//string
func (u *__User_Updater) PasswordHash(newVal string) *__User_Updater {
	up := updateCol{"PasswordHash = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" PasswordHash = "+ u.nextDollar()] = newVal
	return u
}

//ints

//string
func (u *__User_Updater) PasswordSalt(newVal string) *__User_Updater {
	up := updateCol{"PasswordSalt = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" PasswordSalt = "+ u.nextDollar()] = newVal
	return u
}

//ints

func (u *__User_Updater) PostSeq(newVal int) *__User_Updater {
	up := updateCol{" PostSeq = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" PostSeq = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) PostSeq_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" PostSeq = PostSeq+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" PostSeq = PostSeq+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" PostSeq = PostSeq- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" PostSeq = PostSeq- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) FollowersCount(newVal int) *__User_Updater {
	up := updateCol{" FollowersCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" FollowersCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) FollowersCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" FollowersCount = FollowersCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" FollowersCount = FollowersCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" FollowersCount = FollowersCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" FollowersCount = FollowersCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) FollowingCount(newVal int) *__User_Updater {
	up := updateCol{" FollowingCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" FollowingCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) FollowingCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" FollowingCount = FollowingCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" FollowingCount = FollowingCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" FollowingCount = FollowingCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" FollowingCount = FollowingCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) PostsCount(newVal int) *__User_Updater {
	up := updateCol{" PostsCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" PostsCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) PostsCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" PostsCount = PostsCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" PostsCount = PostsCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" PostsCount = PostsCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" PostsCount = PostsCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) MediaCount(newVal int) *__User_Updater {
	up := updateCol{" MediaCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" MediaCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) MediaCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" MediaCount = MediaCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" MediaCount = MediaCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" MediaCount = MediaCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" MediaCount = MediaCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) PhotoCount(newVal int) *__User_Updater {
	up := updateCol{" PhotoCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" PhotoCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) PhotoCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" PhotoCount = PhotoCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" PhotoCount = PhotoCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" PhotoCount = PhotoCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" PhotoCount = PhotoCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) VideoCount(newVal int) *__User_Updater {
	up := updateCol{" VideoCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" VideoCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) VideoCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" VideoCount = VideoCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" VideoCount = VideoCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" VideoCount = VideoCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" VideoCount = VideoCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) GifCount(newVal int) *__User_Updater {
	up := updateCol{" GifCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" GifCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) GifCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" GifCount = GifCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" GifCount = GifCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" GifCount = GifCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" GifCount = GifCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) AudioCount(newVal int) *__User_Updater {
	up := updateCol{" AudioCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" AudioCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) AudioCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" AudioCount = AudioCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" AudioCount = AudioCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" AudioCount = AudioCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" AudioCount = AudioCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) VoiceCount(newVal int) *__User_Updater {
	up := updateCol{" VoiceCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" VoiceCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) VoiceCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" VoiceCount = VoiceCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" VoiceCount = VoiceCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" VoiceCount = VoiceCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" VoiceCount = VoiceCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) FileCount(newVal int) *__User_Updater {
	up := updateCol{" FileCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" FileCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) FileCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" FileCount = FileCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" FileCount = FileCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" FileCount = FileCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" FileCount = FileCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) LinkCount(newVal int) *__User_Updater {
	up := updateCol{" LinkCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" LinkCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) LinkCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" LinkCount = LinkCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" LinkCount = LinkCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" LinkCount = LinkCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" LinkCount = LinkCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) BoardCount(newVal int) *__User_Updater {
	up := updateCol{" BoardCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" BoardCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) BoardCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" BoardCount = BoardCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" BoardCount = BoardCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" BoardCount = BoardCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" BoardCount = BoardCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) PinedCount(newVal int) *__User_Updater {
	up := updateCol{" PinedCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" PinedCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) PinedCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" PinedCount = PinedCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" PinedCount = PinedCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" PinedCount = PinedCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" PinedCount = PinedCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) LikesCount(newVal int) *__User_Updater {
	up := updateCol{" LikesCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" LikesCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) LikesCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" LikesCount = LikesCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" LikesCount = LikesCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" LikesCount = LikesCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" LikesCount = LikesCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) ResharedCount(newVal int) *__User_Updater {
	up := updateCol{" ResharedCount = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" ResharedCount = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) ResharedCount_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" ResharedCount = ResharedCount+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" ResharedCount = ResharedCount+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" ResharedCount = ResharedCount- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" ResharedCount = ResharedCount- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) LastPostTime(newVal int) *__User_Updater {
	up := updateCol{" LastPostTime = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" LastPostTime = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) LastPostTime_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" LastPostTime = LastPostTime+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" LastPostTime = LastPostTime+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" LastPostTime = LastPostTime- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" LastPostTime = LastPostTime- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) CreatedTime(newVal int) *__User_Updater {
	up := updateCol{" CreatedTime = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" CreatedTime = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) CreatedTime_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" CreatedTime = CreatedTime+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" CreatedTime = CreatedTime+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" CreatedTime = CreatedTime- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" CreatedTime = CreatedTime- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) VersionTime(newVal int) *__User_Updater {
	up := updateCol{" VersionTime = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" VersionTime = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) VersionTime_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" VersionTime = VersionTime+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" VersionTime = VersionTime+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" VersionTime = VersionTime- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" VersionTime = VersionTime- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) IsDeleted(newVal int) *__User_Updater {
	up := updateCol{" IsDeleted = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" IsDeleted = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) IsDeleted_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" IsDeleted = IsDeleted+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" IsDeleted = IsDeleted+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" IsDeleted = IsDeleted- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" IsDeleted = IsDeleted- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

//ints

func (u *__User_Updater) IsBanned(newVal int) *__User_Updater {
	up := updateCol{" IsBanned = " + u.nextDollar(), newVal}
	u.updates = append(u.updates, up)
	// u.updates[" IsBanned = " + u.nextDollar()] = newVal
	return u
}

func (u *__User_Updater) IsBanned_Increment(count int) *__User_Updater {
	if count > 0 {
		up := updateCol{" IsBanned = IsBanned+ " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		//u.updates[" IsBanned = IsBanned+ " + u.nextDollar()] = count
	}

	if count < 0 {
		up := updateCol{" IsBanned = IsBanned- " + u.nextDollar(), count}
		u.updates = append(u.updates, up)
		// u.updates[" IsBanned = IsBanned- " + u.nextDollar() ] = -(count) //make it positive
	}

	return u
}

//string

/////////////////////////////////////////////////////////////////////
/////////////////////// Selector ///////////////////////////////////

//Select_* can just be used with: .GetString() , .GetStringSlice(), .GetInt() ..GetIntSlice()

func (u *__User_Selector) OrderBy_UserId_Desc() *__User_Selector {
	u.orderBy = " ORDER BY UserId DESC "
	return u
}

func (u *__User_Selector) OrderBy_UserId_Asc() *__User_Selector {
	u.orderBy = " ORDER BY UserId ASC "
	return u
}

func (u *__User_Selector) Select_UserId() *__User_Selector {
	u.selectCol = "UserId"
	return u
}

func (u *__User_Selector) OrderBy_UserName_Desc() *__User_Selector {
	u.orderBy = " ORDER BY UserName DESC "
	return u
}

func (u *__User_Selector) OrderBy_UserName_Asc() *__User_Selector {
	u.orderBy = " ORDER BY UserName ASC "
	return u
}

func (u *__User_Selector) Select_UserName() *__User_Selector {
	u.selectCol = "UserName"
	return u
}

func (u *__User_Selector) OrderBy_UserNameLower_Desc() *__User_Selector {
	u.orderBy = " ORDER BY UserNameLower DESC "
	return u
}

func (u *__User_Selector) OrderBy_UserNameLower_Asc() *__User_Selector {
	u.orderBy = " ORDER BY UserNameLower ASC "
	return u
}

func (u *__User_Selector) Select_UserNameLower() *__User_Selector {
	u.selectCol = "UserNameLower"
	return u
}

func (u *__User_Selector) OrderBy_FirstName_Desc() *__User_Selector {
	u.orderBy = " ORDER BY FirstName DESC "
	return u
}

func (u *__User_Selector) OrderBy_FirstName_Asc() *__User_Selector {
	u.orderBy = " ORDER BY FirstName ASC "
	return u
}

func (u *__User_Selector) Select_FirstName() *__User_Selector {
	u.selectCol = "FirstName"
	return u
}

func (u *__User_Selector) OrderBy_LastName_Desc() *__User_Selector {
	u.orderBy = " ORDER BY LastName DESC "
	return u
}

func (u *__User_Selector) OrderBy_LastName_Asc() *__User_Selector {
	u.orderBy = " ORDER BY LastName ASC "
	return u
}

func (u *__User_Selector) Select_LastName() *__User_Selector {
	u.selectCol = "LastName"
	return u
}

func (u *__User_Selector) OrderBy_IsVerified_Desc() *__User_Selector {
	u.orderBy = " ORDER BY IsVerified DESC "
	return u
}

func (u *__User_Selector) OrderBy_IsVerified_Asc() *__User_Selector {
	u.orderBy = " ORDER BY IsVerified ASC "
	return u
}

func (u *__User_Selector) Select_IsVerified() *__User_Selector {
	u.selectCol = "IsVerified"
	return u
}

func (u *__User_Selector) OrderBy_AvatarId_Desc() *__User_Selector {
	u.orderBy = " ORDER BY AvatarId DESC "
	return u
}

func (u *__User_Selector) OrderBy_AvatarId_Asc() *__User_Selector {
	u.orderBy = " ORDER BY AvatarId ASC "
	return u
}

func (u *__User_Selector) Select_AvatarId() *__User_Selector {
	u.selectCol = "AvatarId"
	return u
}

func (u *__User_Selector) OrderBy_ProfilePrivacy_Desc() *__User_Selector {
	u.orderBy = " ORDER BY ProfilePrivacy DESC "
	return u
}

func (u *__User_Selector) OrderBy_ProfilePrivacy_Asc() *__User_Selector {
	u.orderBy = " ORDER BY ProfilePrivacy ASC "
	return u
}

func (u *__User_Selector) Select_ProfilePrivacy() *__User_Selector {
	u.selectCol = "ProfilePrivacy"
	return u
}

func (u *__User_Selector) OrderBy_OnlinePrivacy_Desc() *__User_Selector {
	u.orderBy = " ORDER BY OnlinePrivacy DESC "
	return u
}

func (u *__User_Selector) OrderBy_OnlinePrivacy_Asc() *__User_Selector {
	u.orderBy = " ORDER BY OnlinePrivacy ASC "
	return u
}

func (u *__User_Selector) Select_OnlinePrivacy() *__User_Selector {
	u.selectCol = "OnlinePrivacy"
	return u
}

func (u *__User_Selector) OrderBy_CallPrivacy_Desc() *__User_Selector {
	u.orderBy = " ORDER BY CallPrivacy DESC "
	return u
}

func (u *__User_Selector) OrderBy_CallPrivacy_Asc() *__User_Selector {
	u.orderBy = " ORDER BY CallPrivacy ASC "
	return u
}

func (u *__User_Selector) Select_CallPrivacy() *__User_Selector {
	u.selectCol = "CallPrivacy"
	return u
}

func (u *__User_Selector) OrderBy_AddToGroupPrivacy_Desc() *__User_Selector {
	u.orderBy = " ORDER BY AddToGroupPrivacy DESC "
	return u
}

func (u *__User_Selector) OrderBy_AddToGroupPrivacy_Asc() *__User_Selector {
	u.orderBy = " ORDER BY AddToGroupPrivacy ASC "
	return u
}

func (u *__User_Selector) Select_AddToGroupPrivacy() *__User_Selector {
	u.selectCol = "AddToGroupPrivacy"
	return u
}

func (u *__User_Selector) OrderBy_SeenMessagePrivacy_Desc() *__User_Selector {
	u.orderBy = " ORDER BY SeenMessagePrivacy DESC "
	return u
}

func (u *__User_Selector) OrderBy_SeenMessagePrivacy_Asc() *__User_Selector {
	u.orderBy = " ORDER BY SeenMessagePrivacy ASC "
	return u
}

func (u *__User_Selector) Select_SeenMessagePrivacy() *__User_Selector {
	u.selectCol = "SeenMessagePrivacy"
	return u
}

func (u *__User_Selector) OrderBy_Phone_Desc() *__User_Selector {
	u.orderBy = " ORDER BY Phone DESC "
	return u
}

func (u *__User_Selector) OrderBy_Phone_Asc() *__User_Selector {
	u.orderBy = " ORDER BY Phone ASC "
	return u
}

func (u *__User_Selector) Select_Phone() *__User_Selector {
	u.selectCol = "Phone"
	return u
}

func (u *__User_Selector) OrderBy_Email_Desc() *__User_Selector {
	u.orderBy = " ORDER BY Email DESC "
	return u
}

func (u *__User_Selector) OrderBy_Email_Asc() *__User_Selector {
	u.orderBy = " ORDER BY Email ASC "
	return u
}

func (u *__User_Selector) Select_Email() *__User_Selector {
	u.selectCol = "Email"
	return u
}

func (u *__User_Selector) OrderBy_About_Desc() *__User_Selector {
	u.orderBy = " ORDER BY About DESC "
	return u
}

func (u *__User_Selector) OrderBy_About_Asc() *__User_Selector {
	u.orderBy = " ORDER BY About ASC "
	return u
}

func (u *__User_Selector) Select_About() *__User_Selector {
	u.selectCol = "About"
	return u
}

func (u *__User_Selector) OrderBy_PasswordHash_Desc() *__User_Selector {
	u.orderBy = " ORDER BY PasswordHash DESC "
	return u
}

func (u *__User_Selector) OrderBy_PasswordHash_Asc() *__User_Selector {
	u.orderBy = " ORDER BY PasswordHash ASC "
	return u
}

func (u *__User_Selector) Select_PasswordHash() *__User_Selector {
	u.selectCol = "PasswordHash"
	return u
}

func (u *__User_Selector) OrderBy_PasswordSalt_Desc() *__User_Selector {
	u.orderBy = " ORDER BY PasswordSalt DESC "
	return u
}

func (u *__User_Selector) OrderBy_PasswordSalt_Asc() *__User_Selector {
	u.orderBy = " ORDER BY PasswordSalt ASC "
	return u
}

func (u *__User_Selector) Select_PasswordSalt() *__User_Selector {
	u.selectCol = "PasswordSalt"
	return u
}

func (u *__User_Selector) OrderBy_PostSeq_Desc() *__User_Selector {
	u.orderBy = " ORDER BY PostSeq DESC "
	return u
}

func (u *__User_Selector) OrderBy_PostSeq_Asc() *__User_Selector {
	u.orderBy = " ORDER BY PostSeq ASC "
	return u
}

func (u *__User_Selector) Select_PostSeq() *__User_Selector {
	u.selectCol = "PostSeq"
	return u
}

func (u *__User_Selector) OrderBy_FollowersCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY FollowersCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_FollowersCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY FollowersCount ASC "
	return u
}

func (u *__User_Selector) Select_FollowersCount() *__User_Selector {
	u.selectCol = "FollowersCount"
	return u
}

func (u *__User_Selector) OrderBy_FollowingCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY FollowingCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_FollowingCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY FollowingCount ASC "
	return u
}

func (u *__User_Selector) Select_FollowingCount() *__User_Selector {
	u.selectCol = "FollowingCount"
	return u
}

func (u *__User_Selector) OrderBy_PostsCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY PostsCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_PostsCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY PostsCount ASC "
	return u
}

func (u *__User_Selector) Select_PostsCount() *__User_Selector {
	u.selectCol = "PostsCount"
	return u
}

func (u *__User_Selector) OrderBy_MediaCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY MediaCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_MediaCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY MediaCount ASC "
	return u
}

func (u *__User_Selector) Select_MediaCount() *__User_Selector {
	u.selectCol = "MediaCount"
	return u
}

func (u *__User_Selector) OrderBy_PhotoCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY PhotoCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_PhotoCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY PhotoCount ASC "
	return u
}

func (u *__User_Selector) Select_PhotoCount() *__User_Selector {
	u.selectCol = "PhotoCount"
	return u
}

func (u *__User_Selector) OrderBy_VideoCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY VideoCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_VideoCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY VideoCount ASC "
	return u
}

func (u *__User_Selector) Select_VideoCount() *__User_Selector {
	u.selectCol = "VideoCount"
	return u
}

func (u *__User_Selector) OrderBy_GifCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY GifCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_GifCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY GifCount ASC "
	return u
}

func (u *__User_Selector) Select_GifCount() *__User_Selector {
	u.selectCol = "GifCount"
	return u
}

func (u *__User_Selector) OrderBy_AudioCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY AudioCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_AudioCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY AudioCount ASC "
	return u
}

func (u *__User_Selector) Select_AudioCount() *__User_Selector {
	u.selectCol = "AudioCount"
	return u
}

func (u *__User_Selector) OrderBy_VoiceCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY VoiceCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_VoiceCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY VoiceCount ASC "
	return u
}

func (u *__User_Selector) Select_VoiceCount() *__User_Selector {
	u.selectCol = "VoiceCount"
	return u
}

func (u *__User_Selector) OrderBy_FileCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY FileCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_FileCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY FileCount ASC "
	return u
}

func (u *__User_Selector) Select_FileCount() *__User_Selector {
	u.selectCol = "FileCount"
	return u
}

func (u *__User_Selector) OrderBy_LinkCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY LinkCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_LinkCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY LinkCount ASC "
	return u
}

func (u *__User_Selector) Select_LinkCount() *__User_Selector {
	u.selectCol = "LinkCount"
	return u
}

func (u *__User_Selector) OrderBy_BoardCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY BoardCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_BoardCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY BoardCount ASC "
	return u
}

func (u *__User_Selector) Select_BoardCount() *__User_Selector {
	u.selectCol = "BoardCount"
	return u
}

func (u *__User_Selector) OrderBy_PinedCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY PinedCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_PinedCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY PinedCount ASC "
	return u
}

func (u *__User_Selector) Select_PinedCount() *__User_Selector {
	u.selectCol = "PinedCount"
	return u
}

func (u *__User_Selector) OrderBy_LikesCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY LikesCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_LikesCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY LikesCount ASC "
	return u
}

func (u *__User_Selector) Select_LikesCount() *__User_Selector {
	u.selectCol = "LikesCount"
	return u
}

func (u *__User_Selector) OrderBy_ResharedCount_Desc() *__User_Selector {
	u.orderBy = " ORDER BY ResharedCount DESC "
	return u
}

func (u *__User_Selector) OrderBy_ResharedCount_Asc() *__User_Selector {
	u.orderBy = " ORDER BY ResharedCount ASC "
	return u
}

func (u *__User_Selector) Select_ResharedCount() *__User_Selector {
	u.selectCol = "ResharedCount"
	return u
}

func (u *__User_Selector) OrderBy_LastPostTime_Desc() *__User_Selector {
	u.orderBy = " ORDER BY LastPostTime DESC "
	return u
}

func (u *__User_Selector) OrderBy_LastPostTime_Asc() *__User_Selector {
	u.orderBy = " ORDER BY LastPostTime ASC "
	return u
}

func (u *__User_Selector) Select_LastPostTime() *__User_Selector {
	u.selectCol = "LastPostTime"
	return u
}

func (u *__User_Selector) OrderBy_CreatedTime_Desc() *__User_Selector {
	u.orderBy = " ORDER BY CreatedTime DESC "
	return u
}

func (u *__User_Selector) OrderBy_CreatedTime_Asc() *__User_Selector {
	u.orderBy = " ORDER BY CreatedTime ASC "
	return u
}

func (u *__User_Selector) Select_CreatedTime() *__User_Selector {
	u.selectCol = "CreatedTime"
	return u
}

func (u *__User_Selector) OrderBy_VersionTime_Desc() *__User_Selector {
	u.orderBy = " ORDER BY VersionTime DESC "
	return u
}

func (u *__User_Selector) OrderBy_VersionTime_Asc() *__User_Selector {
	u.orderBy = " ORDER BY VersionTime ASC "
	return u
}

func (u *__User_Selector) Select_VersionTime() *__User_Selector {
	u.selectCol = "VersionTime"
	return u
}

func (u *__User_Selector) OrderBy_IsDeleted_Desc() *__User_Selector {
	u.orderBy = " ORDER BY IsDeleted DESC "
	return u
}

func (u *__User_Selector) OrderBy_IsDeleted_Asc() *__User_Selector {
	u.orderBy = " ORDER BY IsDeleted ASC "
	return u
}

func (u *__User_Selector) Select_IsDeleted() *__User_Selector {
	u.selectCol = "IsDeleted"
	return u
}

func (u *__User_Selector) OrderBy_IsBanned_Desc() *__User_Selector {
	u.orderBy = " ORDER BY IsBanned DESC "
	return u
}

func (u *__User_Selector) OrderBy_IsBanned_Asc() *__User_Selector {
	u.orderBy = " ORDER BY IsBanned ASC "
	return u
}

func (u *__User_Selector) Select_IsBanned() *__User_Selector {
	u.selectCol = "IsBanned"
	return u
}

func (u *__User_Selector) Limit(num int) *__User_Selector {
	u.limit = num
	return u
}

func (u *__User_Selector) Offset(num int) *__User_Selector {
	u.offset = num
	return u
}

func (u *__User_Selector) Order_Rand() *__User_Selector {
	u.orderBy = " ORDER BY RAND() "
	return u
}

/////////////////////////  Queryer Selector  //////////////////////////////////
func (u *__User_Selector) _stoSql() (string, []interface{}) {
	sqlWherrs, whereArgs := whereClusesToSql(u.wheres, u.whereSep)

	sqlstr := "SELECT " + u.selectCol + " FROM sun.user"

	if len(strings.Trim(sqlWherrs, " ")) > 0 { //2 for safty
		sqlstr += " WHERE " + sqlWherrs
	}

	if u.orderBy != "" {
		sqlstr += u.orderBy
	}

	if u.limit != 0 {
		sqlstr += " LIMIT " + strconv.Itoa(u.limit)
	}

	if u.offset != 0 {
		sqlstr += " OFFSET " + strconv.Itoa(u.offset)
	}
	return sqlstr, whereArgs
}

func (u *__User_Selector) GetRow(db *sqlx.DB) (*User, error) {
	var err error

	sqlstr, whereArgs := u._stoSql()

	if LogTableSqlReq.User {
		XOLog(sqlstr, whereArgs)
	}

	row := &User{}
	//by Sqlx
	err = db.Get(row, sqlstr, whereArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return nil, err
	}

	row._exists = true

	OnUser_LoadOne(row)

	return row, nil
}

func (u *__User_Selector) GetRows(db *sqlx.DB) ([]*User, error) {
	var err error

	sqlstr, whereArgs := u._stoSql()

	if LogTableSqlReq.User {
		XOLog(sqlstr, whereArgs)
	}

	var rows []*User
	//by Sqlx
	err = db.Unsafe().Select(&rows, sqlstr, whereArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return nil, err
	}

	/*for i:=0;i< len(rows);i++ {
		rows[i]._exists = true
	}*/

	for i := 0; i < len(rows); i++ {
		rows[i]._exists = true
	}

	OnUser_LoadMany(rows)

	return rows, nil
}

//dep use GetRows()
func (u *__User_Selector) GetRows2(db *sqlx.DB) ([]User, error) {
	var err error

	sqlstr, whereArgs := u._stoSql()

	if LogTableSqlReq.User {
		XOLog(sqlstr, whereArgs)
	}
	var rows []*User
	//by Sqlx
	err = db.Unsafe().Select(&rows, sqlstr, whereArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return nil, err
	}

	/*for i:=0;i< len(rows);i++ {
		rows[i]._exists = true
	}*/

	for i := 0; i < len(rows); i++ {
		rows[i]._exists = true
	}

	OnUser_LoadMany(rows)

	rows2 := make([]User, len(rows))
	for i := 0; i < len(rows); i++ {
		cp := *rows[i]
		rows2[i] = cp
	}

	return rows2, nil
}

func (u *__User_Selector) GetString(db *sqlx.DB) (string, error) {
	var err error

	sqlstr, whereArgs := u._stoSql()

	if LogTableSqlReq.User {
		XOLog(sqlstr, whereArgs)
	}

	var res string
	//by Sqlx
	err = db.Get(&res, sqlstr, whereArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return "", err
	}

	return res, nil
}

func (u *__User_Selector) GetStringSlice(db *sqlx.DB) ([]string, error) {
	var err error

	sqlstr, whereArgs := u._stoSql()

	if LogTableSqlReq.User {
		XOLog(sqlstr, whereArgs)
	}
	var rows []string
	//by Sqlx
	err = db.Select(&rows, sqlstr, whereArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return nil, err
	}

	return rows, nil
}

func (u *__User_Selector) GetIntSlice(db *sqlx.DB) ([]int, error) {
	var err error

	sqlstr, whereArgs := u._stoSql()

	if LogTableSqlReq.User {
		XOLog(sqlstr, whereArgs)
	}
	var rows []int
	//by Sqlx
	err = db.Select(&rows, sqlstr, whereArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return nil, err
	}

	return rows, nil
}

func (u *__User_Selector) GetInt(db *sqlx.DB) (int, error) {
	var err error

	sqlstr, whereArgs := u._stoSql()

	if LogTableSqlReq.User {
		XOLog(sqlstr, whereArgs)
	}
	var res int
	//by Sqlx
	err = db.Get(&res, sqlstr, whereArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return 0, err
	}

	return res, nil
}

/////////////////////////  Queryer Update Delete //////////////////////////////////
func (u *__User_Updater) Update(db XODB) (int, error) {
	var err error

	var updateArgs []interface{}
	var sqlUpdateArr []string
	/*for up, newVal := range u.updates {
	    sqlUpdateArr = append(sqlUpdateArr, up)
	    updateArgs = append(updateArgs, newVal)
	}*/
	for _, up := range u.updates {
		sqlUpdateArr = append(sqlUpdateArr, up.col)
		updateArgs = append(updateArgs, up.val)
	}
	sqlUpdate := strings.Join(sqlUpdateArr, ",")

	sqlWherrs, whereArgs := whereClusesToSql(u.wheres, u.whereSep)

	var allArgs []interface{}
	allArgs = append(allArgs, updateArgs...)
	allArgs = append(allArgs, whereArgs...)

	sqlstr := `UPDATE sun.user SET ` + sqlUpdate

	if len(strings.Trim(sqlWherrs, " ")) > 0 { //2 for safty
		sqlstr += " WHERE " + sqlWherrs
	}

	if LogTableSqlReq.User {
		XOLog(sqlstr, allArgs)
	}
	res, err := db.Exec(sqlstr, allArgs...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return 0, err
	}

	num, err := res.RowsAffected()
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return 0, err
	}

	return int(num), nil
}

func (d *__User_Deleter) Delete(db XODB) (int, error) {
	var err error
	var wheresArr []string
	for _, w := range d.wheres {
		wheresArr = append(wheresArr, w.condition)
	}
	wheresStr := strings.Join(wheresArr, d.whereSep)

	var args []interface{}
	for _, w := range d.wheres {
		args = append(args, w.args...)
	}

	sqlstr := "DELETE FROM sun.user WHERE " + wheresStr

	// run query
	if LogTableSqlReq.User {
		XOLog(sqlstr, args)
	}
	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return 0, err
	}

	// retrieve id
	num, err := res.RowsAffected()
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return 0, err
	}

	return int(num), nil
}

///////////////////////// Mass insert - replace for  User ////////////////

func MassInsert_User(rows []User, db XODB) error {
	if len(rows) == 0 {
		return errors.New("rows slice should not be empty - inserted nothing")
	}
	var err error
	ln := len(rows)
	s := "(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)," //`(?, ?, ?, ?),`
	insVals_ := strings.Repeat(s, ln)
	insVals := insVals_[0 : len(insVals_)-1]
	// sql query
	sqlstr := "INSERT INTO sun.user (" +
		"UserName, UserNameLower, FirstName, LastName, IsVerified, AvatarId, ProfilePrivacy, OnlinePrivacy, CallPrivacy, AddToGroupPrivacy, SeenMessagePrivacy, Phone, Email, About, PasswordHash, PasswordSalt, PostSeq, FollowersCount, FollowingCount, PostsCount, MediaCount, PhotoCount, VideoCount, GifCount, AudioCount, VoiceCount, FileCount, LinkCount, BoardCount, PinedCount, LikesCount, ResharedCount, LastPostTime, CreatedTime, VersionTime, IsDeleted, IsBanned" +
		") VALUES " + insVals

	// run query
	vals := make([]interface{}, 0, ln*5) //5 fields

	for _, row := range rows {
		// vals = append(vals,row.UserId)
		vals = append(vals, row.UserName)
		vals = append(vals, row.UserNameLower)
		vals = append(vals, row.FirstName)
		vals = append(vals, row.LastName)
		vals = append(vals, row.IsVerified)
		vals = append(vals, row.AvatarId)
		vals = append(vals, row.ProfilePrivacy)
		vals = append(vals, row.OnlinePrivacy)
		vals = append(vals, row.CallPrivacy)
		vals = append(vals, row.AddToGroupPrivacy)
		vals = append(vals, row.SeenMessagePrivacy)
		vals = append(vals, row.Phone)
		vals = append(vals, row.Email)
		vals = append(vals, row.About)
		vals = append(vals, row.PasswordHash)
		vals = append(vals, row.PasswordSalt)
		vals = append(vals, row.PostSeq)
		vals = append(vals, row.FollowersCount)
		vals = append(vals, row.FollowingCount)
		vals = append(vals, row.PostsCount)
		vals = append(vals, row.MediaCount)
		vals = append(vals, row.PhotoCount)
		vals = append(vals, row.VideoCount)
		vals = append(vals, row.GifCount)
		vals = append(vals, row.AudioCount)
		vals = append(vals, row.VoiceCount)
		vals = append(vals, row.FileCount)
		vals = append(vals, row.LinkCount)
		vals = append(vals, row.BoardCount)
		vals = append(vals, row.PinedCount)
		vals = append(vals, row.LikesCount)
		vals = append(vals, row.ResharedCount)
		vals = append(vals, row.LastPostTime)
		vals = append(vals, row.CreatedTime)
		vals = append(vals, row.VersionTime)
		vals = append(vals, row.IsDeleted)
		vals = append(vals, row.IsBanned)

	}

	if LogTableSqlReq.User {
		XOLog(sqlstr, " MassInsert len = ", ln, vals)
	}
	_, err = db.Exec(sqlstr, vals...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return err
	}

	return nil
}

func MassReplace_User(rows []User, db XODB) error {
	var err error
	ln := len(rows)
	s := "(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)," //`(?, ?, ?, ?),`
	insVals_ := strings.Repeat(s, ln)
	insVals := insVals_[0 : len(insVals_)-1]
	// sql query
	sqlstr := "REPLACE INTO sun.user (" +
		"UserName, UserNameLower, FirstName, LastName, IsVerified, AvatarId, ProfilePrivacy, OnlinePrivacy, CallPrivacy, AddToGroupPrivacy, SeenMessagePrivacy, Phone, Email, About, PasswordHash, PasswordSalt, PostSeq, FollowersCount, FollowingCount, PostsCount, MediaCount, PhotoCount, VideoCount, GifCount, AudioCount, VoiceCount, FileCount, LinkCount, BoardCount, PinedCount, LikesCount, ResharedCount, LastPostTime, CreatedTime, VersionTime, IsDeleted, IsBanned" +
		") VALUES " + insVals

	// run query
	vals := make([]interface{}, 0, ln*5) //5 fields

	for _, row := range rows {
		// vals = append(vals,row.UserId)
		vals = append(vals, row.UserName)
		vals = append(vals, row.UserNameLower)
		vals = append(vals, row.FirstName)
		vals = append(vals, row.LastName)
		vals = append(vals, row.IsVerified)
		vals = append(vals, row.AvatarId)
		vals = append(vals, row.ProfilePrivacy)
		vals = append(vals, row.OnlinePrivacy)
		vals = append(vals, row.CallPrivacy)
		vals = append(vals, row.AddToGroupPrivacy)
		vals = append(vals, row.SeenMessagePrivacy)
		vals = append(vals, row.Phone)
		vals = append(vals, row.Email)
		vals = append(vals, row.About)
		vals = append(vals, row.PasswordHash)
		vals = append(vals, row.PasswordSalt)
		vals = append(vals, row.PostSeq)
		vals = append(vals, row.FollowersCount)
		vals = append(vals, row.FollowingCount)
		vals = append(vals, row.PostsCount)
		vals = append(vals, row.MediaCount)
		vals = append(vals, row.PhotoCount)
		vals = append(vals, row.VideoCount)
		vals = append(vals, row.GifCount)
		vals = append(vals, row.AudioCount)
		vals = append(vals, row.VoiceCount)
		vals = append(vals, row.FileCount)
		vals = append(vals, row.LinkCount)
		vals = append(vals, row.BoardCount)
		vals = append(vals, row.PinedCount)
		vals = append(vals, row.LikesCount)
		vals = append(vals, row.ResharedCount)
		vals = append(vals, row.LastPostTime)
		vals = append(vals, row.CreatedTime)
		vals = append(vals, row.VersionTime)
		vals = append(vals, row.IsDeleted)
		vals = append(vals, row.IsBanned)

	}

	if LogTableSqlReq.User {
		XOLog(sqlstr, " MassReplace len = ", ln, vals)
	}
	_, err = db.Exec(sqlstr, vals...)
	if err != nil {
		if LogTableSqlReq.User {
			XOLogErr(err)
		}
		return err
	}

	return nil
}

//////////////////// Play ///////////////////////////////

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//

//
